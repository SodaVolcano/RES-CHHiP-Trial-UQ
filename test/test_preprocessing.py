import numpy as np
import pytest


class TestMapInterval:

    # correctly maps values from one range to another
    def test_correctly_maps_values_from_one_range_to_another(self):
        from_range = (0, 10)
        to_range = (0, 100)
        array = np.array([0, 5, 10])
        expected = np.array([0.0, 50.0, 100.0])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_almost_equal(result, expected)

    # handles empty arrays
    def test_handles_empty_arrays(self):
        from_range = (0, 10)
        to_range = (0, 100)
        array = np.array([])
        expected = np.array([])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_equal(result, expected)

    # handles negative integer ranges
    def test_handles_negative_integer_ranges(self):
        from_range = (-10, 10)
        to_range = (0, 100)
        array = np.array([-10, 0, 10])
        expected = np.array([0.0, 50.0, 100.0])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_almost_equal(result, expected)

    # handles floating point ranges
    def test_handles_floating_point_ranges(self):
        from_range = (0.0, 1.0)
        to_range = (0.0, 100.0)
        array = np.array([0.0, 0.5, 1.0])
        expected = np.array([0.0, 50.0, 100.0])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_almost_equal(result, expected)

    # processes multi-dimensional arrays correctly
    def test_processes_multi_dimensional_arrays_correctly(self):
        from_range = (0, 10)
        to_range = (0, 100)
        array = np.array([[0, 5, 10], [1, 6, 11]])
        expected = np.array([[0.0, 50.0, 100.0], [10.0, 60.0, 110.0]])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_almost_equal(result, expected)

    # handles arrays with a single element
    def test_handles_single_element_array(self):
        from_range = (0, 10)
        to_range = (0, 100)
        array = np.array([5])
        expected = np.array([50.0])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_almost_equal(result, expected)

    # handles arrays with all elements the same
    def test_handles_arrays_with_all_elements_the_same(self):
        from_range = (0, 10)
        to_range = (0, 100)
        array = np.array([5, 5, 5])
        expected = np.array([50.0, 50.0, 50.0])
        from src.data_operations.preprocessing import map_interval

        result = map_interval(from_range, to_range, array)
        np.testing.assert_array_almost_equal(result, expected)


# Generated by CodiumAI

import pytest


class Test_IsotropicGrid:

    # Generates isotropic grid for 1D coordinate arrays
    def test_generates_isotropic_grid_for_1d_coordinate_arrays(self):
        coords = (np.array([0, 2, 4]),)
        expected_output = (np.array([0, 1, 2, 3]),)
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))

    # Empty coordinate arrays
    def test_empty_coordinate_arrays(self):
        coords = (np.array([]),)
        expected_output = (np.array([]),)
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))

    # Handles negative coordinate values correctly
    def test_handles_negative_coordinates_correctly(self):
        coords = (np.array([-4, -2, 0]),)
        expected_output = (np.array([-4, -3, -2, -1, 0]),)
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))

    # Generates isotropic grid for 3D coordinate arrays
    def test_generates_isotropic_grid_for_3d_coordinate_arrays(self):
        coords = (np.array([0, 2, 4]), np.array([1, 3, 5]), np.array([10, 20, 30]))
        expected_output = (
            np.array([0, 1, 2, 3]),
            np.array([1, 2, 3, 4]),
            np.array(
                [
                    10,
                    11,
                    12,
                    13,
                    14,
                    15,
                    16,
                    17,
                    18,
                    19,
                    20,
                    21,
                    22,
                    23,
                    24,
                    25,
                    26,
                    27,
                    28,
                    29,
                ]
            ),
        )
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))

    # Coordinate arrays with a single element
    def test_generates_isotropic_grid_for_single_element_array(self):
        coords = (np.array([5]),)
        expected_output = (np.array([5]),)
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))

    # Coordinate arrays with repeating values
    def test_coordinate_arrays_with_repeating_values(self):
        coords = (np.array([0, 1, 1, 2, 2, 3]),)
        expected_output = (np.array([0, 1, 2]),)
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))

    # Handles mixed positive and negative coordinate values
    def test_handles_mixed_positive_and_negative_coordinates(self):
        coords = (np.array([-3, -1, 0, 2, 4]), np.array([-2, 0, 1, 3]))
        expected_output = (
            np.array([-3, -2, -1, 0, 1, 2, 3]),
            np.array([-2, -1, 0, 1, 2, 3]),
        )
        from src.data_operations.preprocessing import _isotropic_grid

        result = _isotropic_grid(coords)
        assert all(np.array_equal(r, e) for r, e in zip(result, expected_output))
