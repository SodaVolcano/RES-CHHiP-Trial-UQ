from typing import Generator

import uncertainty.utils

from .context import uncertainty

# Import aliases
list_files = uncertainty.utils.path.list_files
generate_full_paths = uncertainty.utils.path.generate_full_paths
capture_placeholders = uncertainty.utils.string.capture_placeholders
placeholder_matches = uncertainty.utils.string.placeholder_matches
resolve_path_placeholders = uncertainty.utils.path.resolve_path_placeholders

PATCH_OS_WALK = "os.walk"
PATCH_LIST_FILES = "uncertainty.utils.path.list_files"


class TestListFiles:

    # returns all files in a directory
    def test_returns_all_files_in_directory(self, mocker):
        mock_os_walk = mocker.patch(
            PATCH_OS_WALK,
            return_value=[
                ("/path", ("subdir",), ("file1.txt", "file2.txt", "file$pec!al.txt")),
                ("/path/subdir", (), ("file3.txt",)),
            ],
        )

        result = list(list_files("/path"))
        expected = [
            "/path/file1.txt",
            "/path/file2.txt",
            "/path/file$pec!al.txt",
            "/path/subdir/file3.txt",
        ]
        assert result == expected

    # empty directory returns no files
    def test_empty_directory_returns_no_files(self, mocker):
        mock_os_walk = mocker.patch(
            PATCH_OS_WALK, return_value=[("/empty_path", (), ())]
        )

        result = list(list_files("/empty_path"))
        assert result == []

    # directory with only subdirectories returns no files
    def test_directory_with_only_subdirectories_returns_no_files(self, mocker):
        mock_os_walk = mocker.patch(
            PATCH_OS_WALK,
            return_value=[
                ("/path", ("subdir1", "subdir2"), ()),
                ("/path/subdir1", (), ()),
                ("/path/subdir2", (), ()),
            ],
        )

        result = list(list_files("/path"))
        expected = []
        assert list(result) == expected

    # handles directories with hidden files
    def test_handles_directories_with_hidden_files(self, mocker):
        mock_os_walk = mocker.patch(
            PATCH_OS_WALK,
            return_value=[
                ("/path", ("subdir",), ("file1.txt", ".hidden_file", "file2.txt")),
                ("/path/subdir", (), ("file3.txt",)),
            ],
        )

        result = list(list_files("/path"))
        expected = ["/path/file1.txt", "/path/file2.txt", "/path/subdir/file3.txt"]
        assert result == expected


class TestGenerateFullPaths:

    # generates full paths correctly when root and path_generator provide valid inputs
    def test_generates_full_paths_correctly(self):
        def mock_path_generator(root):
            return ["file1.txt", "file2.txt", "dir/file3.txt"]

        root = "/home/user"
        expected_paths = [
            "/home/user/file1.txt",
            "/home/user/file2.txt",
            "/home/user/dir/file3.txt",
        ]

        result = list(generate_full_paths(root, mock_path_generator))
        assert result == expected_paths

    # handles empty strings for root and paths
    def test_handles_empty_strings(self):
        def mock_path_generator(root):
            return ["", "file.txt", "dir/"]

        root = ""
        expected_paths = ["", "file.txt", "dir/"]

        result = list(generate_full_paths(root, mock_path_generator))
        assert result == expected_paths

    # handles path_generator returning an empty list
    def test_handles_empty_path_generator(self):
        def mock_path_generator(root):
            return []

        root = "/home/user"
        expected_paths = []

        result = list(generate_full_paths(root, mock_path_generator))
        assert result == expected_paths

    # ensures generator is lazy and does not compute paths upfront
    def test_lazy_generation(self):
        def mock_path_generator(root):
            return ["file1.txt", "file2.txt", "dir/file3.txt"]

        root = "/home/user"
        expected_paths = [
            "/home/user/file1.txt",
            "/home/user/file2.txt",
            "/home/user/dir/file3.txt",
        ]

        result = generate_full_paths(root, mock_path_generator)
        assert isinstance(result, Generator)
        assert list(result) == expected_paths


# Generated by CodiumAI

import pytest


class TestCapturePlaceholders:

    # correctly replaces placeholders with default regex pattern
    def test_correctly_replaces_placeholders_with_default_regex_pattern(self):
        s = "somestuff{a}_{b}adf{c}."
        placeholders = ["a", "b"]
        expected = "somestuff(.*?)_(.*?)adf.*?\\."

        result = capture_placeholders(s, placeholders, r".*?")
        assert result == expected

    # handles empty string input
    def test_handles_empty_string_input(self):
        s = ""
        placeholders = ["a", "b"]
        expected = ""

        result = capture_placeholders(s, placeholders)
        assert result == expected

    # handles strings with no placeholders gracefully
    def test_handles_strings_with_no_placeholders_gracefully(self):
        s = "no placeholders here"
        placeholders = []
        expected = "no\\ placeholders\\ here"

        result = capture_placeholders(s, placeholders)
        assert result == expected

    # handles empty list of placeholders
    def test_handles_empty_list_of_placeholders(self):
        s = "somestuff{a}_{b}.nii.gz"
        placeholders = []
        expected = "somestuff.*?_.*?\\.nii\\.gz"

        result = capture_placeholders(s, placeholders, r".*?")
        assert result == expected


class TestPlaceholderMatches:

    # Matches placeholders correctly in a list of strings
    def test_matches_placeholders_correctly(self):
        str_list = [
            "/path/to/eye_sp.nii.gz",
            "/path/to/bladder_jd.nii.gz",
            "/path/to/brain_md.nii.gz",
        ]
        pattern = "/path/to/{organ}_{observer}.nii.gz"
        placeholders = ["organ", "observer"]
        expected_output = [("eye", "sp"), ("bladder", "jd"), ("brain", "md")]

        result = placeholder_matches(str_list, pattern, placeholders)

        assert all([x in expected_output for x in result])

    # Handles empty list of strings
    def test_handles_empty_list_of_strings(self):
        str_list = []
        pattern = "/path/to/{organ}_{observer}.nii.gz"
        placeholders = ["organ", "observer"]
        expected_output = []

        result = placeholder_matches(str_list, pattern, placeholders)

        assert result == expected_output

    # Handles empty list of placeholders
    def test_handles_empty_list_of_placeholders(self):
        str_list = [
            "/path/to/bladder_jd.nii.gz",
            "/path/to/brain_md.nii.gz",
            "/path/to/eye_sp.nii.gz",
        ]
        pattern = "/path/to/{organ}_{observer}.nii.gz"
        placeholders = []
        expected_output = [(), (), ()]

        result = placeholder_matches(str_list, pattern, placeholders)

        assert result == expected_output

    # Handles patterns with placeholders not present in the strings
    def test_handles_patterns_with_placeholders_not_present(self):
        str_list = [
            "/path/to/bladder_jd.nii.gz",
            "/path/to/brain_md.nii.gz",
            "/path/to/eye_sp.nii.gz",
        ]
        pattern = "to/{organ}_{observer}_{a}.nii.gz"
        placeholders = ["organ", "observer", "a"]
        re_pattern = r".+"
        expected_output = []

        result = placeholder_matches(str_list, pattern, placeholders, re_pattern)

        assert result == expected_output

    # Handles empty pattern string
    def test_handles_empty_pattern_string(self):
        str_list = [
            "/path/to/bladder_jd.nii.gz",
            "/path/to/brain_md.nii.gz",
            "/path/to/eye_sp.nii.gz",
        ]
        pattern = ""
        placeholders = ["organ", "observer"]
        expected_output = [(), (), ()]

        result = placeholder_matches(str_list, pattern, placeholders)

        assert result == expected_output


class TestResolvePathPlaceholders:

    # Resolves placeholders correctly for simple path patterns with single-level directories
    def test_resolves_placeholders_simple_path(self, mocker):

        # Mock list_files to return a predefined list of files
        mocker.patch(
            PATCH_LIST_FILES,
            return_value=["/a/val1/val2/d/e.jpg", "/a/val3/val4/d/e.jpg"],
        )

        path_pattern = "/a/{b}/{c}/d/{e}.jpg"
        placeholders = ["b", "c"]

        expected = ["/a/val1/val2/d/{e}.jpg", "/a/val3/val4/d/{e}.jpg"]

        result = resolve_path_placeholders(path_pattern, placeholders)
        assert result == expected

    # Handles empty directory gracefully
    def test_handles_empty_directory(self, mocker):

        # Mock list_files to return an empty list
        mocker.patch(PATCH_LIST_FILES, return_value=[])

        path_pattern = "/a/{b}/{c}/d/{e}.jpg"
        placeholders = ["b", "c"]

        expected = []

        result = resolve_path_placeholders(path_pattern, placeholders)
        assert result == expected

    # Handles non-existent directories
    def test_handles_non_existent_directories(self, mocker):

        # Mock list_files to return an empty list for non-existent directories
        mocker.patch(PATCH_LIST_FILES, return_value=[])

        path_pattern = "/non_existent/{b}/{c}/d/{e}.jpg"
        placeholders = ["b", "c"]

        expected = []

        result = resolve_path_placeholders(path_pattern, placeholders)
        assert result == expected

    # Handles patterns with no placeholders
    def test_handles_patterns_with_no_placeholders(self, mocker):

        # Mock list_files to return a predefined list of files
        mocker.patch(
            PATCH_LIST_FILES,
            return_value=["/a/val1/val2/d/e.jpg", "/a/val3/val4/d/e.jpg"],
        )

        path_pattern = "/a/val1/val2/d/e.jpg"
        placeholders = []

        expected = [path_pattern]

        result = resolve_path_placeholders(path_pattern, placeholders)
        assert result == expected

    # Test that when string have leading empty placeholders, only specified placeholder is replaced
    def test_leading_empty_placeholders_replacement(self, mocker):

        # Mock list_files to return a predefined list of files
        mocker.patch(
            PATCH_LIST_FILES,
            return_value=[
                "/a/val1/val2/d/e.jpg",
                "/a/val3/val4/d/e.jpg",
                "/a/val5/val6/d/e.jpg",
                "/a/val7/val8/d/e.jpg",
            ],
        )

        path_pattern = "/{}/{t1}/{t2}/d/{t3}.jpg"
        placeholders = ["t2"]

        expected = [
            "/{}/{t1}/val2/d/{t3}.jpg",
            "/{}/{t1}/val4/d/{t3}.jpg",
            "/{}/{t1}/val6/d/{t3}.jpg",
            "/{}/{t1}/val8/d/{t3}.jpg",
        ]

        result = resolve_path_placeholders(path_pattern, placeholders)
        assert result == expected

    # Test that replacement is correct using placeholders with diferent order than in path
    def test_different_order_placeholders(self, mocker):

        # Mock list_files to return a predefined list of files
        mocker.patch(
            PATCH_LIST_FILES,
            return_value=[
                "/a/val1/val2/d/e.jpg",
                "/a/val3/val4/d/e.jpg",
                "/a/val5/val6/d/e.jpg",
                "/a/val7/val8/d/e.jpg",
            ],
        )

        path_pattern = "/{}/{t1}/{t2}/d/{t3}.jpg"
        placeholders = ["t3", "t1", "t2"]

        expected = resolve_path_placeholders(path_pattern, ["t1", "t2", "t3"])

        result = resolve_path_placeholders(path_pattern, placeholders)
        assert result == expected
